---
c1: debug
c2: analyze-deep
c3: project-issues
title: プロジェクト全体の深掘り調査と修正タスク洗い出し
description: プロジェクト全体を深く調査し、リファクタ課題や重複コード、修正すべき問題を洗い出し、ドメイン駆動設計からテスト駆動設計への移行を支援する
usage: "inspector-debug analyze-deep project-issues"
options:
  input: []
  adaptation: []
  file: [false]
  stdin: [true]
  destination: [false]
---

# 指示:

以下の2点のいずれかをランダムに選択し、実施して。

1. プロジェクト全体を深く調査し、リファクタ課題や重複コード、修正すべき問題を洗い出して。具体的には「プロジェクトの深掘り調査」を実行すること。
2. 要求→設計→テスト駆動設計へ進め、テストが要求や仕様を反映していない箇所を洗い出して。カバレッジではなく仕様のTDDを優先する。具体的には「設計の実装調査」を実行すること。

## 強固構築方針

- **ドメイン駆動設計**: ビジネスロジックとドメインモデルを中核とした堅牢な設計
- **全域性原則**:
  型安全性による不正状態の完全排除（`docs/development/totality_go.ja.md`参照）
- **強固性重視**: 障害耐性、保守性、拡張性を重視した堅牢な構築
- [AI複雑化防止（科学的制御）](docs/development/ai-complexity-control_compact.ja.md)
- [ハードコーディング禁止規定](docs/development/prohibit-hardcoding.ja.md)

## 必須参照資料

必ず以下の資料を参照してから強固な設計・実装を開始すること：

1. **ドメイン設計**: `docs/domain/domain_boundary-*.md`
2. **サブドメイン設計**: `docs/domain/architecture/**/*.md`
3. **全域性原則**: `docs/development/totality_go.ja.md`
4. **テスト方針**: `docs/tests/README.md`, `docs/tests/testing_guidelines.md`
5. **ハードコーディング禁止規定**: `docs/development/prohibit-hardcoding.ja.md`

### check list

過去のIssueから作成したCheckListであり、この問題が対処済みであることも重要。
チェックリスト: `docs/tests/checklist-based-on-gh-issue.md`

## プロジェクトの深掘り調査

要求が期待するフローの最適案を構築:

### 発散フェーズ:

以下の処理手順に従う。

1. まず「要求」ファイルを読み込む。( docs/requirements.ja.md, docs/flow.ja.md )
2. 「要求」を満たすデータの連鎖フローを3パターン考える。CLI開始地点から出力完了までを網羅すること。
3. ３パターンからランダムに1つ選ぶ（「要求に基づくデータフロー」とする）
4. 「要求に基づくデータフロー」を実行シミュレーション:
   「要求に基づくデータフロー」を実現するためのCLI実行案を2つ作成する（「CLI実行案」とする）
5. 「要求に基づくデータフロー」を実行シミュレーション: 「CLI実行案」を2つシミュレーション実行する
6. 「要求に基づくデータフロー」を実行シミュレーション:
   「CLI実行案」の2つを比較し、実行結果を得る（「CLI実行シミュレート案の実行推測結果」とする）
7. 実行推測結果の比較:
   「CLI実行シミュレーション案の実行推測結果」を相互に比較する。処理と処理の結果の違いの差分幅を「処理フローの実行結果の振れ幅」とする。
8. 実行推測結果の比較:
   「処理フローの実行結果の振れ幅」は実装の「揺れ」や「不具合」「二重実装」の温床となることを認識する
9. 実行推測結果の比較:
   実装の振れ幅を減らすために、振れ幅が大きくなる箇所を見定め、「デバッグ対象箇所」と認定する
10. 実装へのデバッグ出力追加:
    コードを調べて、「デバッグ対象箇所」へ、十分なデバッグ情報を加える
    デバッグ情報を加える具体的な指示は、 `inspector-debug trace-error cause-analysis` を実行して得る。
11. 実装へのデバッグ出力追加:
    デバッグ情報にログレベルを設定し、実行時にログ出力の量や情報量を制御する（文字数、ログ出力）
12. 実装へのデバッグ出力追加:
    プロセスでは、if文による特殊分岐がハードコーディングされていないか調べる（要求は特殊解でなく抽象度で満たせ。場当たり的実装を禁ず。）
13. 実装へのデバッグ出力追加: 実際にコードを実行し、デバッグ出力結果を得る
14. デバッグした結果の評価:
    デバッグ実行した結果を、処理1の「要求」と照らし合わせる
15. デバッグした結果の評価:
    「要求」に対し、比較した結果が、要求を満たすか判定する

## 設計の実装調査

以下の処理手順に従う。

設計調査:

1. 要求や要件を理解する（ docs/docs/requirements.ja.md や docs/flow.ja.md ）
2. ドメイン境界線やアーキテクチャなどの設計書を読む (docs/domain/, docs/architecture)
3. 要求に従って考えられる実行例を24個列挙する
4. 24個列挙した実行例をもとに、特殊解に縛る実装を禁止し、要求を抽象度に即して一般解として設計する(「概念的設計」とする)
5. 実装調査:
   実装とテストから、分岐が多い箇所や、責任が大きい箇所を選ぶ（それらを「中心点」とする。複数存在する。）
6. 実装調査: 複数の中心点から、ランダムに1つ選ぶ
7. 設計調査と実装調査の比較評価:
   選んだ中心点に対し、処理4の「概念的設計」を下敷とし、「強固構築方針」や「必須参照資料」を元に比較評価する
8. 設計調査と実装調査の比較評価:
   評価した結果が、1の要求・要件を満たしているか判定する
9. 設計調査と実装調査の比較評価:
   8の判定結果に基づいて、テストがTDD実装されているか調べる。
   TDDテスト方法は、`inspector-debug plan-logger debug-strategy` を実行した結果の指示が示す BreakdwonLogger 戦略を組み込む。
10. 設計調査と実装調査の比較評価:
    処理4で導いた「概念的設計」に基づき、テスト設計を行い、処理9のテスト実装が仕様をテストしているか否か判定する。
    テストしていない場合は、テスト未実装の課題である。テストしているがテストがエラーの場合は実装の課題である。テストしてpassしているのに実装が正しくない場合はTDDの不備が課題である。

# 課題がある場合

既存のissue一覧を gh で取得し、問題に近いIssueがあるか調べる。
「近いIssueがない場合」と「近いIssueがある場合」に応じて、処理を変え、実施する。

その後「Issue登録後のデバッグワークフロー作成手順」を実施する。

## 近いIssueがない場合:

gh で 適切なラベルをつけてIssueを作って。

- Issueへ完了条件を明記すること。
- Issueへ「経過をコメントへ残す」旨の記述をすること。

### ラベル

[bug, ci-failure, duplicate, enhancement, refactor, documentation,
high-priority]

## 近いIssueがある場合:

gh でIssue内容を変更する。

- 既存Issueの内容と照らし合わせ、修正点を加筆・修正する。
- 完了条件を見直し、必要な条件を追記・削除する。
- ラベルを見直し、変更する。

Issue コメントへ、変更した点を記載する。

## Issue登録後のデバッグワークフロー作成手順

以下の実行コマンドをsh実行し表示される指示へ従い、今回のデバッグに関するワークフローを作成する。

実行コマンド: `inspector-debug design-flow reproducible-steps`

1. 既存ワークフローがあるか調べる
2. すでにあれば既存を修正する（修正不要ならそのまま）
3. なければ追加する
4. 全体ワークフローを調べ、相互の実行関係を整理する

# 何も課題がない場合

## debug 手順を実行する

`docs/tests/debugs/*.workflow.md` に沿って、デバッグを実行する。

## デバッグ手順に従っても問題がない場合

ひとつも問題がなく、修正も全て完了している場合は、リリースIssueを作成する。

gh で ラベル "release" を含む Issueを作成して。 全部で30行以内に収めること。

Issueへの登録内容:

- Releaseノートに含める文言
- 実装が確認された内容のサマリー
