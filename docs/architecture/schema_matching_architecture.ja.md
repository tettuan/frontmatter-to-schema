# TypeScriptによるSchema一致とテンプレート変換処理

# 処理の分解

TypeScriptで処理を行う際には、1度にまとめて変換せず、以下のように段階を分ける。  
抽出フェーズと、Schemaとのパターンマッチフェーズを明確に分離する。

TypeScriptでSchemaを扱う場合、単純な文字列PATH化だけでは不十分である。  
**Schema構造を考慮し、プロパティ階層・型・配列要素を統合的に扱う** ことで正しいマッピングを行う。  

---

## 1. 抽出フェーズ

### 1-1. フロントマター抽出
- 入力テキストから **フロントマター部分のみを抽出** し、YAMLとしてパースする。  
- 得られたデータを「フロントマターYAML」として保持する。 
- ファイル本文中のフロントマターに一致しないよう、先頭だけ使う。

### 1-2. テンプレート変数抽出
- テンプレート本文に含まれる `{SchemaPath}` 形式の変数を正規表現で抽出する。  
- `SchemaPath` は単純な `a.b.c` 形式ではなく、  
  - オブジェクト → `tools.commands[].options.input`  
  - 配列 → `tools.availableConfigs[0]`  
  のように Schema に基づいた正しい表現とする。  
- 抽出した変数名を一覧として保持する。  

---

## 2. Schemaマッピングフェーズ

### 2-1. Schema展開
- JSON Schema を再帰的に走査し、**パスと型情報を同時に展開** する。  
- 各エントリは次の形式で保持する：  
  ```ts
  {
    path: "tools.commands[].options.input",
    type: "array<string>",
    description: "Supported input formats",
    required: true
  }
  ```

### 2-2. フロントマターとの対応付け
- フロントマターの各キーを同様に「階層 + 型情報」へ正規化する。  
- Schema展開情報と比較し、次の手順でマッピングする：  
  1. **親階層一致** を強く優先する（`tools.commands[].options` 内の `input` なら、その階層内でのみ比較する）。  
  2. **キー名称の類似度** を計算する（レーベンシュタイン/Jaro-Winkler）。  
  3. **型が一致しない場合は棄却**。  
- マッチした値は Schema に適合するJSON構造として保持する。  

ルール:
- 値は加工しない。  
- Schemaに存在しない項目は利用しない。  
- 必須項目（`required` に含まれる）が欠落している場合は警告を出す。  

---

## 3. テンプレート当て込みフェーズ

### 3-1. `{SchemaPath}` の置換処理
- テンプレート本文に含まれる `{SchemaPath}` を走査する。  
- Schema展開情報から対応する値を検索し、存在すれば置換する。  
- 値が存在しない場合の扱い：  
  - 必須項目ならエラーや警告を出す。  
  - 任意項目なら空文字または削除。  

### 3-2. 配列・オブジェクトへの対応
- `{tools.availableConfigs}` の場合 → 配列を展開し、JSON表現やCSV表現に変換可能とする。  
- `{tools.commands[].c1}` の場合 → コマンド配列を走査し、各要素に対して置換を行う。  

---

## 実装のポイント

- **YAML処理**: `js-yaml` を利用。  
- **Schema展開**: 型・配列要素を含めて `path:type` の形式にflattenする関数を用意。  
- **マッチング**: 類似度スコア + 型チェックでフィルタリング。  
- **テンプレート処理**: `{...}` を正規表現で抽出し、構造化されたSchemaパスに基づき置換。  
- **必須判定**: `required` を利用して警告・エラー制御を行う。  

---

## 出力

- Schemaに対応づけられたJSONデータ（必須/任意判定付き）  
- `{SchemaPath}` を置換済みのテンプレート本文  
- 欠落必須項目の一覧と警告
