# 構造化要求仕様書

## エグゼクティブサマリー

本仕様書は、Markdownファイルのフロントマターを柔軟に解析し、索引を生成するシステムの要求事項を構造化したものです。AIを活用した事後的な型定義により、多様なフロントマター形式に対応し、Schema変更に柔軟に対応できるアーキテクチャを実現します。

## 1. プロセス分解

### 1.1 主要プロセス

#### P1: フロントマター解析プロセス

- **誰が**: システム（自動処理エンジン）
- **何を**: Markdownファイル群のフロントマター
- **どのように**: AIを活用した柔軟な抽出・解析・構造化を通じて処理
- **MoSCoW**: Must Have（必須）

##### P1.1: ファイル収集サブプロセス

- **誰が**: ファイルシステムスキャナー
- **何を**: 指定ディレクトリ内のMarkdownファイル
- **どのように**: 再帰的スキャンによりファイルリストを生成
- **MoSCoW**: Must Have（必須）
- **理由**: 処理対象の特定が全体処理の前提条件

##### P1.2: フロントマター抽出サブプロセス

- **誰が**: Denoランタイム（抽出エンジン）
- **何を**: 各Markdownファイルの先頭部分のYAML/TOML形式データ
- **どのように**: パーサーを使用して構造化データとして抽出
- **MoSCoW**: Must Have（必須）
- **理由**: 解析対象データの取得が必須

##### P1.3: 情報抽出サブプロセス

- **誰が**: TypeScript処理エンジン
- **何を**: 抽出されたフロントマターデータ（成果B）
- **どのように**:
  Schema展開とマッピング処理により、フロントマターと解析結果のSchemaから情報を抽出
- **入力**: 成果B（フロントマター） + 解析結果のSchema
- **出力**: 成果C（抽出された情報）
- **MoSCoW**: Must Have（必須）
- **理由**: 構造化解析の第1段階

##### P1.4: テンプレート当て込みサブプロセス

- **誰が**: TypeScript処理エンジン
- **何を**: 抽出結果（成果C）
- **どのように**: 型安全な変数置換により、抽出情報を解析テンプレートへ当て込む
- **入力**: 成果C（抽出された情報） + 解析結果のSchema
- **出力**: 成果D（構造化されたデータ）
- **MoSCoW**: Must Have（必須）
- **理由**: 柔軟な解析の第2段階、出力形式の統一性確保
- **関係**: P1.3の出力（成果C）を入力として使用する直列処理

##### P1.5: 結果統合サブプロセス

- **誰が**: 統合エンジン
- **何を**: 個別の解析結果
- **どのように**: 最終成果物Zへの統合と保存
- **MoSCoW**: Must Have（必須）
- **理由**: 最終成果物の生成

#### P2: 設定管理プロセス

- **誰が**: システム管理者
- **何を**: Schema定義とテンプレート設定
- **どのように**: 外部ファイルによる差し替え可能な設定管理
- **MoSCoW**: Must Have（必須）
- **理由**: 柔軟性確保の要

##### P2.1: Schema管理サブプロセス

- **誰が**: 設定管理システム
- **何を**: JSON Schema定義ファイル
- **どのように**: 外部ファイルからの読み込みと検証
- **MoSCoW**: Must Have（必須）

##### P2.2: テンプレート管理サブプロセス

- **誰が**: 設定管理システム
- **何を**: 出力テンプレートファイル（JSON/YAML形式）
- **どのように**: 動的ロードと変数置換処理
- **MoSCoW**: Must Have（必須）

#### P3: 品質保証プロセス

- **誰が**: テスト実行システム
- **何を**: 実装されたスクリプトと機能
- **どのように**: 自動テストとexamplesによる検証
- **MoSCoW**: Should Have（推奨）
- **理由**: 品質保証のため重要だが、コア機能ではない

## 2. ユーザーフロー

### 2.1 メインユーザーフロー

#### UF1: 索引生成フロー

**アクター**: システム利用者（開発者/運用者） **目的**:
Markdownファイル群から索引を自動生成

1. **開始条件確認**
   - **誰が**: 利用者
   - **何を**: 処理対象ディレクトリとSchema/テンプレート
   - **どのように**: CLIコマンドまたは設定ファイルで指定
   - **MoSCoW**: Must Have

2. **初期化処理**
   - **誰が**: システム
   - **何を**: 空の最終成果物Z
   - **どのように**: 初期データ構造の生成
   - **MoSCoW**: Must Have

3. **ファイルリスト生成**
   - **誰が**: システム
   - **何を**: 対象ディレクトリ内のMarkdownファイル一覧（成果A）
   - **どのように**: ファイルシステムの再帰的スキャン
   - **MoSCoW**: Must Have

4. **ループ処理実行**
   - **誰が**: システム
   - **何を**: 各Markdownファイル
   - **どのように**: 順次処理または並列処理
   - **MoSCoW**: Must Have

5. **結果確認**
   - **誰が**: 利用者
   - **何を**: 生成された索引ファイル
   - **どのように**: 出力ファイルの検証
   - **MoSCoW**: Must Have

#### UF2: Schema/テンプレート変更フロー

**アクター**: システム管理者 **目的**: 新しい索引形式への対応

1. **要求分析**
   - **誰が**: 管理者
   - **何を**: 新しい索引形式の要求
   - **どのように**: ビジネス要件の確認と技術的実現性の検討
   - **MoSCoW**: Should Have

2. **Schema定義作成**
   - **誰が**: 管理者
   - **何を**: 新しいJSON Schema定義
   - **どのように**: 既存例を参考に作成
   - **MoSCoW**: Must Have

3. **テンプレート作成**
   - **誰が**: 管理者
   - **何を**: 対応する出力テンプレート
   - **どのように**: マッピングルールの定義
   - **MoSCoW**: Must Have

4. **設定更新**
   - **誰が**: 管理者
   - **何を**: アプリケーション設定
   - **どのように**: 設定ファイルの更新または引数指定
   - **MoSCoW**: Must Have

5. **動作検証**
   - **誰が**: 管理者
   - **何を**: 新しい設定での動作
   - **どのように**: examplesディレクトリでのテスト実行
   - **MoSCoW**: Should Have

#### UF3: エラー対応フロー

**アクター**: システム利用者 **目的**: 解析エラーへの対処

1. **エラー検知**
   - **誰が**: システム
   - **何を**: 処理中のエラー
   - **どのように**: エラーハンドリング機構による検知と報告
   - **MoSCoW**: Must Have

2. **原因特定**
   - **誰が**: 利用者
   - **何を**: エラーログとスタックトレース
   - **どのように**: ログファイルの分析
   - **MoSCoW**: Should Have

3. **対処選択**
   - **誰が**: 利用者
   - **何を**: エラー対処方法
   - **どのように**:
     - フロントマター修正
     - Schema/プロンプト調整
     - 該当ファイルのスキップ
   - **MoSCoW**: Should Have

4. **再実行**
   - **誰が**: 利用者
   - **何を**: 修正後の処理
   - **どのように**: 同一コマンドの再実行
   - **MoSCoW**: Should Have

## 3. 機能要件

### 3.1 コア機能要件

#### FR1: フロントマター抽出機能

- **説明**: Markdownファイルからフロントマターを抽出
- **MoSCoW**: Must Have
- **詳細**:
  - YAML形式のサポート（必須）
  - TOML/JSON形式のサポート（Should Have）
  - カスタム区切り文字対応（Could Have）

#### FR2: TypeScript解析機能（2段階処理）

- **説明**: TypeScriptによる2段階の柔軟な解析
- **MoSCoW**: Must Have
- **詳細**:
  - **第1段階（情報抽出）**:
    - プロンプトAの使用（必須）
    - フロントマターと解析結果のSchemaから情報抽出（必須）
    - 成果B（フロントマター）→ 成果C（抽出情報）への変換（必須）
  - **第2段階（テンプレート当て込み）**:
    - プロンプトBの使用（必須）
    - 抽出情報の解析テンプレートへの当て込み（必須）
    - 成果C（抽出情報）→ 成果D（構造化データ）への変換（必須）
  - レート制限対応（Should Have）

#### FR3: Schema適用機能

- **説明**: 解析結果のSchemaによる処理制御
- **MoSCoW**: Must Have
- **詳細**:
  - 解析結果のSchema定義（JSON Schema形式）（必須）
  - TypeScript解析の両段階でSchemaを参照（必須）
  - Schema検証機能（必須）
  - 外部ファイルからの読み込み（必須）
  - バージョン管理（Should Have）

#### FR4: テンプレート処理機能

- **説明**: 解析テンプレートによる最終出力形式の制御
- **MoSCoW**: Must Have
- **詳細**:
  - TypeScriptの第2段階で使用される解析テンプレート（必須）
  - JSON形式テンプレート対応（必須）
  - YAML形式テンプレート対応（必須）
  - 外部ファイルからの読み込み（必須）
  - カスタム形式（Could Have）

#### FR5: 設定管理機能

- **説明**: 外部設定による柔軟な制御
- **MoSCoW**: Must Have
- **詳細**:
  - Schema/テンプレートの外部化（必須）
  - パス設定の外部化（必須）
  - 複数プロファイル対応（Should Have）

### 3.2 抽象化要件

#### AR1: 実装の汎用性

- **説明**: 特定の実例に依存しない実装
- **MoSCoW**: Must Have
- **詳細**:
  - 実例1-2のパターンを混入しない
  - Schema変更がコードに影響しない
  - 階層構造変更がコードに影響しない

#### AR2: 設定による制御

- **説明**: 設定または引数による動作制御
- **MoSCoW**: Must Have
- **詳細**:
  - 入力パスの設定
  - 出力パスの設定
  - Schema/テンプレートの指定

## 4. 非機能要件

### 4.1 性能要件

- **処理速度**: 100ファイル/分以上（Should Have）
- **並列処理**: 対応（Could Have）
- **メモリ使用量**: 1GB以下（Should Have）

### 4.2 信頼性要件

- **エラー処理**: 部分的な結果保存（Must Have）
- **リトライ機能**: 3回まで自動リトライ（Should Have）
- **ログ出力**: 詳細なエラーログ（Must Have）

### 4.3 保守性要件

- **モジュール化**: DDD原則に基づく設計（Must Have）
- **テストカバレッジ**: 80%以上（Should Have）
- **ドキュメント**: 自動生成対応（Could Have）

### 4.4 拡張性要件

- **プラグイン**: 拡張可能なアーキテクチャ（Must Have）
- **新Schema対応**: 追加が容易（Must Have）
- **新形式対応**: プラグインによる拡張（Should Have）

## 5. ドメイン境界

### 5.1 コアドメイン

- **フロントマター解析ドメイン**
  - 抽出ロジック
  - 解析ロジック
  - 構造化ロジック

### 5.2 サポートドメイン

- **ファイル管理ドメイン**
  - ファイルシステム操作
  - パス管理

- **AI連携ドメイン**
  - Claude API通信
  - プロンプト管理

- **設定管理ドメイン**
  - Schema管理
  - テンプレート管理

### 5.3 汎用ドメイン

- **ロギングドメイン**
- **エラーハンドリング**
- **ユーティリティ**

## 6. 成果物定義

### 6.1 ドキュメント成果物

1. **要求仕様書**（本書）- Must Have
2. **機能要件/非機能要件書** - Must Have
3. **ドメイン境界設計書** - Must Have
4. **API仕様書** - Should Have
5. **運用マニュアル** - Should Have

### 6.2 実装成果物

1. **解析スクリプト**（Deno/TypeScript）- Must Have
2. **堅牢なテストスイート** - Must Have
3. **TypeScript処理ロジック（2段階）** - Must Have
   - 第1段階: Schema展開とマッピング（成果B→成果C）
   - 第2段階: テンプレート変数置換（成果C→成果D）
4. **実行例（examples/）** - Must Have
   - 実例1: Climpt registry生成
   - 実例2: 記事索引生成

### 6.3 設定成果物

1. **解析結果のSchemaファイル例** - Must Have
2. **解析テンプレートファイル例** - Must Have
3. **設定ファイルテンプレート** - Should Have

## 7. 実装優先順位

### Phase 1: MVP（Minimum Viable Product）

1. フロントマター抽出機能
2. TypeScript解析機能（2段階処理）
   - 第1段階：情報抽出（Schema展開とマッピング）
   - 第2段階：テンプレート当て込み（変数置換処理）
3. JSON形式での出力
4. 実例1の動作

### Phase 2: 機能拡張

1. YAML形式サポート
2. エラーハンドリング強化
3. 実例2の動作
4. テストスイート充実

### Phase 3: 最適化

1. 並列処理対応
2. パフォーマンス最適化
3. プラグインシステム
4. ドキュメント自動生成

## 8. リスクと対策

### 8.1 技術的リスク

- **AI API制限**: レート制限対策とキャッシュ機構
- **Schema複雑性**: 段階的な検証とエラーメッセージ改善
- **性能問題**: 並列処理とバッチ処理の実装

### 8.2 運用リスク

- **設定ミス**: 設定検証機能と詳細なエラーメッセージ
- **データ不整合**: トランザクション的な処理と復旧機能

## 9. 制約事項

### 9.1 技術制約

- Denoランタイムの使用（必須）
- Claude APIの利用（必須）
- TypeScriptでの実装（必須）

### 9.2 設計制約

- DDD原則の適用（必須）
- TDD実践（推奨）
- 全体性（Totality）の確保（必須）
- AI複雑性制御の実装（必須）

### 9.3 運用制約

- CLIベースの実装（必須）
- 設定ファイルベースの管理（必須）
- ローカル実行環境での動作（必須）

## 10. 成功基準

1. ✅ 全ての必須要件（Must Have）の実装完了
2. ✅ 実例1,2の正常動作
3. ✅ テストカバレッジ80%以上
4. ✅ Schema/テンプレート変更時のコード修正不要
5. ✅ 100ファイル/分以上の処理速度達成
