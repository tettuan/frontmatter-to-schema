/**
 * Result Aggregation Service
 *
 * Handles aggregation and formatting of processing results following
 * Single Responsibility Principle. Extracted from ProcessDocumentsUseCase
 * to improve maintainability and reduce AI complexity.
 */

import {
  type DomainError,
  isError,
  isOk,
  type Result,
} from "../../domain/core/result.ts";
import type { AnalysisResult } from "../../domain/models/entities.ts";
import type {
  ProcessingConfiguration,
  ResultAggregator,
  ResultRepository,
} from "../../domain/services/interfaces.ts";
import { LoggingDecoratorService } from "../../domain/services/logging-decorator-service.ts";
import { createDomainError } from "../../domain/core/result.ts";

export interface ProcessingResults {
  processedCount: number;
  failedCount: number;
  outputPath: string;
  errors: Array<{ document: string; error: string }>;
}

export interface ProcessingProgress {
  successful: AnalysisResult[];
  errors: Array<{ document: string; error: string }>;
}

/**
 * Service responsible for aggregating and formatting processing results
 */
export class ResultAggregationService {
  constructor(
    private readonly resultRepo: ResultRepository,
    private readonly resultAggregator: ResultAggregator,
  ) {}

  /**
   * Aggregate individual processing results into final output
   */
  async aggregateResults(
    results: Result<AnalysisResult, DomainError & { message: string }>[],
    config: ProcessingConfiguration,
  ): Promise<Result<ProcessingResults, DomainError & { message: string }>> {
    const progress = this.categorizeResults(results);

    if (progress.successful.length === 0) {
      return {
        ok: false,
        error: createDomainError({
          kind: "ProcessingStageError",
          stage: "result aggregation",
          error: { kind: "NotFound", resource: "processed documents" },
        }),
      };
    }

    // Aggregate successful results
    const aggregationResult = await this.resultAggregator.aggregate(
      progress.successful,
    );

    if (isError(aggregationResult)) {
      return {
        ok: false,
        error: createDomainError({
          kind: "ProcessingStageError",
          stage: "result aggregation",
          error: aggregationResult.error,
        }),
      };
    }

    // Save aggregated results
    const saveResult = await this.resultRepo.save(
      aggregationResult.data,
      config.outputPath,
    );

    if (isError(saveResult)) {
      return {
        ok: false,
        error: createDomainError({
          kind: "WriteError",
          path: config.outputPath.getValue(),
          details: saveResult.error.message || "Failed to save results",
        }),
      };
    }

    const finalResults: ProcessingResults = {
      processedCount: progress.successful.length,
      failedCount: progress.errors.length,
      outputPath: config.outputPath.getValue(),
      errors: progress.errors,
    };

    LoggingDecoratorService.logInfo(
      { service: "ResultAggregationService", operation: "aggregateResults" },
      `Results aggregated: ${finalResults.processedCount} processed, ${finalResults.failedCount} failed`,
    );

    return { ok: true, data: finalResults };
  }

  /**
   * Categorize results into successful and failed
   */
  private categorizeResults(
    results: Result<AnalysisResult, DomainError & { message: string }>[],
  ): ProcessingProgress {
    const successful: AnalysisResult[] = [];
    const errors: Array<{ document: string; error: string }> = [];

    for (const result of results) {
      if (isOk(result)) {
        successful.push(result.data);
      } else {
        errors.push({
          document: this.extractDocumentPath(result.error),
          error: result.error.message,
        });
      }
    }

    LoggingDecoratorService.logInfo(
      { service: "ResultAggregationService", operation: "categorizeResults" },
      `Categorized results: ${successful.length} successful, ${errors.length} failed`,
    );

    return { successful, errors };
  }

  /**
   * Extract document path from error for reporting
   */
  private extractDocumentPath(
    error: DomainError & { message: string },
  ): string {
    // Try to extract path from different error types
    if ("path" in error) {
      return (error as { path?: string }).path || "unknown";
    }
    if ("input" in error) {
      return String((error as { input?: unknown }).input || "unknown");
    }
    return "unknown document";
  }

  /**
   * Generate summary report of processing results
   */
  generateSummaryReport(results: ProcessingResults): string {
    const { processedCount, failedCount, outputPath, errors } = results;

    let report = `Processing Summary:\n`;
    report += `- Successfully processed: ${processedCount} documents\n`;
    report += `- Failed: ${failedCount} documents\n`;
    report += `- Output saved to: ${outputPath}\n`;

    if (errors.length > 0) {
      report += `\nErrors:\n`;
      for (const error of errors.slice(0, 10)) { // Limit to first 10 errors
        report += `- ${error.document}: ${error.error}\n`;
      }
      if (errors.length > 10) {
        report += `... and ${errors.length - 10} more errors\n`;
      }
    }

    return report;
  }

  /**
   * Check if processing was successful overall
   */
  isProcessingSuccessful(results: ProcessingResults): boolean {
    return results.processedCount > 0 && results.failedCount === 0;
  }

  /**
   * Check if processing had partial success
   */
  hasPartialSuccess(results: ProcessingResults): boolean {
    return results.processedCount > 0 && results.failedCount > 0;
  }
}
