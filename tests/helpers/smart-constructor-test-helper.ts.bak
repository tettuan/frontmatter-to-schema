/**
 * Smart Constructor Test Helper
 * 
 * Result pattern validation utilities for DDD Smart Constructor testing
 * Following robust test construction patterns and Totality principles
 * 
 * Part of climpt-build robust test architecture for Issue #669
 */

import { assertEquals, assertExists } from "jsr:@std/assert";
import type { Result } from "../../src/domain/core/result.ts";

/**
 * Smart Constructor validation configuration
 */
export interface SmartConstructorTestConfig {
  className: string;
  expectedMethods: string[];
  shouldHavePrivateConstructor: boolean;
  shouldReturnResultType: boolean;
  shouldValidateInputs: boolean;
}

/**
 * Smart Constructor test result
 */
export interface SmartConstructorTestResult {
  className: string;
  hasSmartConstructor: boolean;
  followsResultPattern: boolean;
  hasProperErrorHandling: boolean;
  hasInputValidation: boolean;
  testsPassed: number;
  testsFailed: number;
  errors: string[];
}

/**
 * Unified helper for testing Smart Constructor patterns
 * Ensures reproducible, idempotent validation of Result<T,E> compliance
 */
export class SmartConstructorTestHelper {
  /**
   * Comprehensive Smart Constructor validation
   */
  static validateSmartConstructor<T, E>(
    constructorFunction: Record<string, unknown>,
    config: SmartConstructorTestConfig,
  ): SmartConstructorTestResult {
    const result: SmartConstructorTestResult = {
      className: config.className,
      hasSmartConstructor: false,
      followsResultPattern: false,
      hasProperErrorHandling: false,
      hasInputValidation: false,
      testsPassed: 0,
      testsFailed: 0,
      errors: [],
    };

    try {
      // Test 1: Static create method exists
      if (this.testStaticCreateExists(constructorFunction)) {
        result.hasSmartConstructor = true;
        result.testsPassed++;
      } else {
        result.testsFailed++;
        result.errors.push("Missing static create method");
      }

      // Test 2: Result pattern compliance
      if (this.testResultPatternCompliance(constructorFunction, config)) {
        result.followsResultPattern = true;
        result.testsPassed++;
      } else {
        result.testsFailed++;
        result.errors.push("Does not follow Result<T,E> pattern");
      }

      // Test 3: Error handling capability
      if (this.testErrorHandling(constructorFunction)) {
        result.hasProperErrorHandling = true;
        result.testsPassed++;
      } else {
        result.testsFailed++;
        result.errors.push("Inadequate error handling");
      }

      // Test 4: Input validation
      if (this.testInputValidation(constructorFunction, config)) {
        result.hasInputValidation = true;
        result.testsPassed++;
      } else {
        result.testsFailed++;
        result.errors.push("Missing input validation");
      }

    } catch (error) {
      result.testsFailed++;
      result.errors.push(error instanceof Error ? error.message : String(error));
    }

    return result;
  }

  /**
   * Test that Smart Constructor returns Result<T,E> for valid inputs
   */
  static async testValidInputHandling<T>(
    createFunction: (...args: unknown[]) => Promise<Result<T, unknown>> | Result<T, unknown>,
    validInputs: unknown[],
    testDescription: string,
  ): Promise<void> {
    try {
      const result = await Promise.resolve(createFunction(...validInputs));
      
      // Validate Result structure
      assertExists(result, `${testDescription}: Result should exist`);
      assertEquals(typeof result, "object", `${testDescription}: Result should be object`);
      assertEquals("ok" in result, true, `${testDescription}: Result should have 'ok' property`);
      
      if (result.ok) {
        assertExists(result.data, `${testDescription}: Success result should have data`);
      } else {
        assertExists((result as any).error, `${testDescription}: Error result should have error`);
      }
    } catch (error) {
      throw new Error(`${testDescription} failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Test that Smart Constructor returns error Result for invalid inputs
   */
  static async testInvalidInputHandling<E>(
    createFunction: (...args: any[]) => Promise<Result<any, E>> | Result<any, E>,
    invalidInputs: any[],
    testDescription: string,
  ): Promise<void> {
    try {
      const result = await Promise.resolve(createFunction(...invalidInputs));
      
      // Should return error result, not throw
      assertExists(result, `${testDescription}: Should return Result, not throw`);
      assertEquals(result.ok, false, `${testDescription}: Invalid input should return error Result`);
      assertExists((result as any).error, `${testDescription}: Error Result should have error details`);
      
    } catch (error) {
      // If function throws, it violates Smart Constructor pattern
      throw new Error(`${testDescription}: Smart Constructor should return Result, not throw: ${error}`);
    }
  }

  /**
   * Generate standard test scenarios for Smart Constructor validation
   */
  static generateStandardTestScenarios<T>(className: string): Array<{
    description: string;
    validInputs: any[];
    invalidInputs: any[];
    expectedErrorTypes: string[];
  }> {
    return [
      {
        description: `${className} with valid minimal input`,
        validInputs: ["valid-input"],
        invalidInputs: [null, undefined, "", "   "],
        expectedErrorTypes: ["ValidationError", "InputError"],
      },
      {
        description: `${className} with edge case inputs`,
        validInputs: ["edge-case-valid"],
        invalidInputs: [0, -1, [], {}, true],
        expectedErrorTypes: ["TypeValidationError", "RangeError"],
      },
      {
        description: `${className} with complex valid inputs`,
        validInputs: [{ complex: "valid-object" }],
        invalidInputs: [{ invalid: "structure" }],
        expectedErrorTypes: ["StructureValidationError"],
      },
    ];
  }

  /**
   * Batch test multiple Smart Constructors
   */
  static batchTestSmartConstructors(
    constructors: Array<{
      name: string;
      constructor: any;
      config: SmartConstructorTestConfig;
    }>,
  ): SmartConstructorTestResult[] {
    const results: SmartConstructorTestResult[] = [];
    
    for (const item of constructors) {
      const result = this.validateSmartConstructor(
        item.constructor,
        item.config,
      );
      results.push(result);
    }
    
    return results;
  }

  /**
   * Create comprehensive test assertions for Smart Constructor compliance
   */
  static createSmartConstructorAssertions(result: SmartConstructorTestResult): void {
    // All Smart Constructor tests should pass
    assertEquals(
      result.testsFailed,
      0,
      `Smart Constructor ${result.className} failed ${result.testsFailed} tests: ${result.errors.join(", ")}`,
    );

    // Specific pattern requirements
    assertEquals(
      result.hasSmartConstructor,
      true,
      `${result.className} must have static create method`,
    );

    assertEquals(
      result.followsResultPattern,
      true,
      `${result.className} must follow Result<T,E> pattern`,
    );

    assertEquals(
      result.hasProperErrorHandling,
      true,
      `${result.className} must handle errors properly`,
    );
  }

  /**
   * Private helper: Test static create method exists
   */
  private static testStaticCreateExists(constructorFunction: any): boolean {
    return typeof constructorFunction?.create === "function";
  }

  /**
   * Private helper: Test Result pattern compliance
   */
  private static testResultPatternCompliance(
    constructorFunction: any,
    config: SmartConstructorTestConfig,
  ): boolean {
    if (!constructorFunction?.create) return false;
    
    try {
      // Test with minimal valid input to check return type structure
      const testResult = constructorFunction.create("test-input");
      
      // Check if it's a Result-like structure
      return testResult && 
             typeof testResult === "object" && 
             "ok" in testResult &&
             (testResult.ok ? "data" in testResult : "error" in testResult);
    } catch {
      // If it throws, it's not following Result pattern
      return false;
    }
  }

  /**
   * Private helper: Test error handling capability
   */
  private static testErrorHandling(constructorFunction: any): boolean {
    if (!constructorFunction?.create) return false;
    
    try {
      // Test with invalid input
      const result = constructorFunction.create(null);
      
      // Should return error Result, not throw
      return result && 
             typeof result === "object" && 
             result.ok === false && 
             "error" in result;
    } catch {
      // If it throws on invalid input, error handling is inadequate
      return false;
    }
  }

  /**
   * Private helper: Test input validation
   */
  private static testInputValidation(
    constructorFunction: any,
    config: SmartConstructorTestConfig,
  ): boolean {
    if (!constructorFunction?.create) return false;
    
    // Test various invalid inputs
    const invalidInputs = [null, undefined, "", "   ", 0, -1, [], {}];
    
    try {
      for (const invalidInput of invalidInputs) {
        const result = constructorFunction.create(invalidInput);
        
        // Should return error Result for invalid inputs
        if (!result || result.ok !== false) {
          return false;
        }
      }
      return true;
    } catch {
      // Should not throw on invalid inputs
      return false;
    }
  }

  /**
   * Setup reproducible test environment
   */
  static setupSmartConstructorTestEnvironment(): void {
    // Clean, reproducible environment setup
    // No global state modifications
  }

  /**
   * Cleanup test environment (idempotent)
   */
  static cleanupSmartConstructorTestEnvironment(): void {
    // Idempotent cleanup
    // Safe to call multiple times
  }
}