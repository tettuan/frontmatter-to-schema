import { assertEquals } from "@std/assert";
import {
  IntegrationTestEnvironment,
  TestFileDefinition,
  TestMarkdownFiles,
  TestSchemas,
  TestTemplates,
} from "../helpers/integration-test-helper.ts";
import { BreakdownLogger } from "@tettuan/breakdownlogger";

Deno.test({
  name:
    "ProcessCoordinator - should populate base properties from schema defaults",
  ignore: false, // Testing to identify actual issue
  fn: async () => {
    // LOG_KEY=base-property-population LOG_LENGTH=L で詳細出力
    const logger = new BreakdownLogger("base-property-population");

    // Setup: Create isolated test environment
    const testEnv = new IntegrationTestEnvironment("base-property-population");
    logger.debug("Test environment created", { testEnv: typeof testEnv });

    try {
      // Setup: Create test files with guaranteed isolation
      const testFiles: TestFileDefinition[] = [
        {
          name: "schema.json",
          type: "schema" as const,
          content: JSON.stringify(TestSchemas.withBaseProperties, null, 2),
        },
        {
          name: "test-template.json",
          type: "template" as const,
          content: JSON.stringify(TestTemplates.withBaseProperties, null, 2),
        },
        {
          name: "test-command.md",
          type: "markdown" as const,
          content: TestMarkdownFiles.basicCommandWithoutDescription,
        },
        {
          name: "output.json",
          type: "output" as const,
          content: "", // Will be written by ProcessCoordinator
        },
      ];

      logger.debug("Test files configuration", {
        fileCount: testFiles.length,
        fileNames: testFiles.map((f) => f.name),
      });
      logger.debug("Schema content structure", TestSchemas.withBaseProperties);

      const paths = await testEnv.setupTestFiles(testFiles);
      logger.debug("Setup paths generated", paths);

      // Execute: Run the complete data flow with base property population
      logger.info("Executing processing pipeline", {
        schema: paths.schema,
        output: paths.output,
        pattern: `${paths.schema!.replace("/schema.json", "")}/**/*.md`,
      });

      const result = await testEnv.executeProcessing(
        paths.schema!,
        paths.output!,
        `${paths.schema!.replace("/schema.json", "")}/**/*.md`,
      );

      logger.debug("Processing result", {
        success: result.success,
        hasOutput: !!result.output,
        errorMessage: result.error?.message,
      });

      // Verify: Processing should succeed (Totality principle - handle all error cases)
      if (!result.success) {
        logger.error("ProcessCoordinator error", result.error);
        logger.error("Error context", {
          schema: paths.schema,
          output: paths.output,
          errorMessage: result.error?.message,
        });
        assertEquals(
          result.success,
          true,
          `ProcessCoordinator should succeed. Error: ${result.error?.message}`,
        );
      }

      const parsedOutput = result.output as Record<string, unknown>;
      logger.info("Validating output structure", {
        outputKeys: Object.keys(parsedOutput),
        outputTypes: Object.fromEntries(
          Object.entries(parsedOutput).map(([k, v]) => [k, typeof v]),
        ),
      });

      // CRITICAL: Base properties should be populated with default values (Core Business Rule)
      assertEquals(
        parsedOutput.version,
        "1.0.0",
        "Version should be populated from schema default value",
      );

      assertEquals(
        parsedOutput.description,
        "Generated by frontmatter-to-schema",
        "Description should be populated from schema default value",
      );

      // Verify: Template variables are resolved correctly
      assertEquals(
        parsedOutput.totalCommands,
        "1",
        "Total commands should be resolved to string representation of array length",
      );

      // Verify: Frontmatter data processing works correctly
      // Template renderer converts {commands} to JSON string representation
      assertEquals(
        typeof parsedOutput.commands,
        "string",
        "Commands should be JSON string representation from template rendering",
      );

      // Robust validation: Parse the JSON string to verify structure and content
      let commandsArray;
      try {
        commandsArray = JSON.parse(parsedOutput.commands as string);
      } catch {
        commandsArray = null;
      }

      console.log("TEST DEBUG: parsedOutput.commands:", parsedOutput.commands);
      console.log(
        "TEST DEBUG: commandsArray:",
        JSON.stringify(commandsArray, null, 2),
      );

      assertEquals(
        Array.isArray(commandsArray),
        true,
        "Commands JSON string should parse to valid array",
      );

      if (Array.isArray(commandsArray) && commandsArray.length > 0) {
        const firstCommand = commandsArray[0];
        logger.debug("First command validation", { firstCommand });
        assertEquals(
          firstCommand.name,
          "TestCommand",
          "Command name should match frontmatter data",
        );
        // Note: description not checked since the test markdown doesn't include one
        // This test focuses on base property population, not command properties
      }
    } finally {
      // Cleanup: Guaranteed cleanup following idempotency principle
      logger.info("Test cleanup starting");
      await testEnv.cleanup();
      logger.info("Test completed");
    }
  },
});

Deno.test({
  name:
    "ProcessCoordinator - should not override existing frontmatter values with base properties",
  ignore: false, // Reactivated with robust test design following DDD/Totality principles
  fn: async () => {
    // LOG_KEY=base-property-override LOG_LENGTH=W で完全出力
    const logger = new BreakdownLogger("base-property-override");

    // Setup: Create isolated test environment
    const testEnv = new IntegrationTestEnvironment("base-property-override");

    // Define custom schema for override testing
    const overrideSchema = {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "x-template": "./test-template.json",
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "x-base-property": true,
          "x-default-value": "1.0.0",
        },
        "title": { "type": "string" },
      },
    };

    const overrideTemplate = {
      "version": "{version}",
      "title": "{title}",
    };

    logger.debug("Override schema configuration", overrideSchema);
    logger.debug("Override template structure", overrideTemplate);

    try {
      // Setup: Test files with frontmatter that should override defaults
      const paths = await testEnv.setupTestFiles([
        {
          name: "schema.json",
          type: "schema",
          content: JSON.stringify(overrideSchema, null, 2),
        },
        {
          name: "test-template.json",
          type: "template",
          content: JSON.stringify(overrideTemplate, null, 2),
        },
        {
          name: "test-doc.md",
          type: "markdown",
          content: TestMarkdownFiles.commandWithVersion,
        },
        {
          name: "output.json",
          type: "output",
          content: "",
        },
      ]);

      // Execute: Process documents with override scenario
      const result = await testEnv.executeProcessing(
        paths.schema!,
        paths.output!,
        `${paths.schema!.replace("/schema.json", "")}/**/*.md`,
      );

      // Verify: Processing should succeed (Total function - handle all paths)
      if (!result.success) {
        console.error("ProcessCoordinator error:", result.error);
        assertEquals(
          result.success,
          true,
          `ProcessCoordinator should succeed. Error: ${result.error?.message}`,
        );
      }

      const parsedOutput = result.output as Record<string, unknown>;

      // CRITICAL: Frontmatter values should override base property defaults (Core Business Rule)
      assertEquals(
        parsedOutput.version,
        "2.0.0",
        "Frontmatter version should override schema default (precedence rule)",
      );

      assertEquals(
        parsedOutput.title,
        "Custom Title",
        "Regular frontmatter property should be preserved correctly",
      );
    } finally {
      // Cleanup: Guaranteed cleanup following idempotency principle
      await testEnv.cleanup();
    }
  },
});
