import { assertEquals } from "@std/assert";
import {
  IntegrationTestEnvironment,
  TestMarkdownFiles,
  TestSchemas,
  TestTemplates,
} from "../helpers/integration-test-helper.ts";

Deno.test({
  name:
    "ProcessCoordinator - should populate base properties from schema defaults",
  ignore: false, // Testing to identify actual issue
  fn: async () => {
    // Setup: Create isolated test environment
    const testEnv = new IntegrationTestEnvironment("base-property-population");

    try {
      // Setup: Create test files with guaranteed isolation
      const paths = await testEnv.setupTestFiles([
        {
          name: "schema.json",
          type: "schema",
          content: JSON.stringify(TestSchemas.withBaseProperties, null, 2),
        },
        {
          name: "test-template.json",
          type: "template",
          content: JSON.stringify(TestTemplates.withBaseProperties, null, 2),
        },
        {
          name: "test-command.md",
          type: "markdown",
          content: TestMarkdownFiles.basicCommand,
        },
        {
          name: "output.json",
          type: "output",
          content: "", // Will be written by ProcessCoordinator
        },
      ]);

      // Execute: Run the complete data flow with base property population
      const result = await testEnv.executeProcessing(
        paths.schema!,
        paths.output!,
        `${paths.schema!.replace("/schema.json", "")}/**/*.md`,
      );

      // Verify: Processing should succeed (Totality principle - handle all error cases)
      if (!result.success) {
        console.error("ProcessCoordinator error:", result.error);
        assertEquals(
          result.success,
          true,
          `ProcessCoordinator should succeed. Error: ${result.error?.message}`,
        );
      }

      const parsedOutput = result.output as Record<string, unknown>;

      // CRITICAL: Base properties should be populated with default values (Core Business Rule)
      assertEquals(
        parsedOutput.version,
        "1.0.0",
        "Version should be populated from schema default value",
      );

      assertEquals(
        parsedOutput.description,
        "Generated by frontmatter-to-schema",
        "Description should be populated from schema default value",
      );

      // Verify: Template variables are resolved correctly
      assertEquals(
        parsedOutput.totalCommands,
        "1",
        "Total commands should be resolved to string representation of array length",
      );

      // Verify: Frontmatter data processing works correctly
      // Template renderer converts {commands} to JSON string representation
      assertEquals(
        typeof parsedOutput.commands,
        "string",
        "Commands should be JSON string representation from template rendering",
      );

      // Robust validation: Parse the JSON string to verify structure and content
      let commandsArray;
      try {
        commandsArray = JSON.parse(parsedOutput.commands as string);
      } catch {
        commandsArray = null;
      }

      assertEquals(
        Array.isArray(commandsArray),
        true,
        "Commands JSON string should parse to valid array",
      );

      if (Array.isArray(commandsArray) && commandsArray.length > 0) {
        const firstCommand = commandsArray[0];
        assertEquals(
          firstCommand.name,
          "TestCommand",
          "Command name should match frontmatter data",
        );
        assertEquals(
          firstCommand.description,
          "Test command description",
          "Command description should match frontmatter data",
        );
      }
    } finally {
      // Cleanup: Guaranteed cleanup following idempotency principle
      await testEnv.cleanup();
    }
  },
});

Deno.test({
  name:
    "ProcessCoordinator - should not override existing frontmatter values with base properties",
  ignore: false, // Reactivated with robust test design following DDD/Totality principles
  fn: async () => {
    // Setup: Create isolated test environment
    const testEnv = new IntegrationTestEnvironment("base-property-override");

    // Define custom schema for override testing
    const overrideSchema = {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "x-template": "./test-template.json",
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "x-base-property": true,
          "x-default-value": "1.0.0",
        },
        "title": { "type": "string" },
      },
    };

    const overrideTemplate = {
      "version": "{version}",
      "title": "{title}",
    };

    try {
      // Setup: Test files with frontmatter that should override defaults
      const paths = await testEnv.setupTestFiles([
        {
          name: "schema.json",
          type: "schema",
          content: JSON.stringify(overrideSchema, null, 2),
        },
        {
          name: "test-template.json",
          type: "template",
          content: JSON.stringify(overrideTemplate, null, 2),
        },
        {
          name: "test-doc.md",
          type: "markdown",
          content: TestMarkdownFiles.commandWithVersion,
        },
        {
          name: "output.json",
          type: "output",
          content: "",
        },
      ]);

      // Execute: Process documents with override scenario
      const result = await testEnv.executeProcessing(
        paths.schema!,
        paths.output!,
        `${paths.schema!.replace("/schema.json", "")}/**/*.md`,
      );

      // Verify: Processing should succeed (Total function - handle all paths)
      if (!result.success) {
        console.error("ProcessCoordinator error:", result.error);
        assertEquals(
          result.success,
          true,
          `ProcessCoordinator should succeed. Error: ${result.error?.message}`,
        );
      }

      const parsedOutput = result.output as Record<string, unknown>;

      // CRITICAL: Frontmatter values should override base property defaults (Core Business Rule)
      assertEquals(
        parsedOutput.version,
        "2.0.0",
        "Frontmatter version should override schema default (precedence rule)",
      );

      assertEquals(
        parsedOutput.title,
        "Custom Title",
        "Regular frontmatter property should be preserved correctly",
      );
    } finally {
      // Cleanup: Guaranteed cleanup following idempotency principle
      await testEnv.cleanup();
    }
  },
});
