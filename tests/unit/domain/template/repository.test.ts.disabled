/**
 * Domain-based tests for Template Repository
 * Testing Repository pattern with Smart Constructors and Totality
 */

import { assertEquals, assertExists } from "jsr:@std/assert";
import { TemplatePath } from "../../../../src/domain/template/repository.ts";
import { FileTemplateRepository } from "../../../../src/infrastructure/template/file-template-repository.ts";
import {
  Template,
  TemplateId,
} from "../../../../src/domain/models/entities.ts";
import {
  TemplateFormat,
  MappingRule,
} from "../../../../src/domain/models/value-objects.ts";

// Helper function to create templates with proper entities API
function createTestTemplate(id: string, format: "json" | "yaml" | "handlebars" | "custom", content: string, description = ""): Template {
  const templateIdResult = TemplateId.create(id);
  const templateFormatResult = TemplateFormat.create(format, content);
  
  if (!templateIdResult.ok || !templateFormatResult.ok) {
    throw new Error(`Failed to create template: ${id}`);
  }
  
  return Template.create(
    templateIdResult.data,
    templateFormatResult.data,
    [], // empty mapping rules for test
    description,
  );
}

Deno.test("TemplatePath - Smart Constructor Tests", async (t) => {
  await t.step("should create valid template paths", () => {
    const validPaths = [
      "./templates/test.json",
      "/absolute/path/template.yaml",
      "relative/template.hbs",
      "../parent/template.yml",
      "template", // Path without extension is valid (directory)
    ];

    for (const path of validPaths) {
      const result = TemplatePath.create(path);
      assertEquals(result.ok, true, `Should accept valid path: ${path}`);
      if (result.ok) {
        assertEquals(result.data.getValue(), path);
      }
    }
  });

  await t.step("should reject invalid template paths", () => {
    const invalidPaths = [
      "", // Empty path
      "   ", // Whitespace only
      "test.txt", // Invalid extension
      "test.pdf", // Non-template extension
      null as unknown, // Null
      undefined as unknown, // Undefined
      123 as unknown, // Non-string
    ];

    for (const path of invalidPaths) {
      const result = TemplatePath.create(path as string);
      assertEquals(result.ok, false, `Should reject invalid path: ${path}`);
      if (!result.ok) {
        assertExists(result.error);
        // Should be one of the DomainError kinds: EmptyInput, InvalidFormat, FileExtensionMismatch
        const expectedKinds = [
          "EmptyInput",
          "InvalidFormat",
          "FileExtensionMismatch",
        ];
        assertEquals(
          expectedKinds.includes(result.error.kind),
          true,
          `Expected error kind to be one of ${
            expectedKinds.join(", ")
          }, got ${result.error.kind}`,
        );
      }
    }
  });

  await t.step("should validate template extensions", () => {
    const extensions = [
      { ext: ".json", valid: true },
      { ext: ".yaml", valid: true },
      { ext: ".yml", valid: true },
      { ext: ".hbs", valid: true },
      { ext: ".template", valid: true },
      { ext: ".txt", valid: false },
      { ext: ".md", valid: false },
      { ext: ".js", valid: false },
    ];

    for (const { ext, valid } of extensions) {
      const result = TemplatePath.create(`template${ext}`);
      assertEquals(
        result.ok,
        valid,
        `Extension ${ext} should be ${valid ? "valid" : "invalid"}`,
      );
    }
  });

  await t.step("should be immutable", () => {
    const result = TemplatePath.create("test.json");
    if (result.ok) {
      const path = result.data;
      const value1 = path.getValue();
      const value2 = path.getValue();
      assertEquals(value1, value2, "Should return same value");
      assertEquals(value1, "test.json");
    }
  });
});

Deno.test("FileTemplateRepository - Repository Pattern Tests", async (t) => {
  const testDir = await Deno.makeTempDir();
  const repo = new FileTemplateRepository(testDir);

  await t.step("should save and load templates", async () => {
      const template = createTestTemplate(
        "save-load-test",
        "json",
        JSON.stringify({ test: "{{value}}" }),
        "Test template",
      );
        // Save template
        const saveResult = await repo.save(template);
        assertEquals(saveResult.ok, true, "Should save template successfully");

        // Load template
        const loadResult = await repo.load("save-load-test");
        assertEquals(loadResult.ok, true, "Should load template successfully");
        if (loadResult.ok) {
          assertEquals(loadResult.data.getId().getValue(), "save-load-test");
          assertEquals(loadResult.data.getFormat().getFormat(), "json");
        }
  });

  await t.step("should handle non-existent templates", async () => {
    const result = await repo.load("non-existent-template");
    assertEquals(result.ok, false, "Should fail to load non-existent template");
    if (!result.ok) {
      assertEquals(result.error.kind, "FileNotFound");
      // FileNotFound is a specific error kind
    }
  });

  await t.step("should check template existence", async () => {
      const template = createTestTemplate(
        "exists-test",
        "yaml",
        "test",
        "Exists test",
      );
      await repo.save(template);

      const exists1 = await repo.exists("exists-test");
      assertEquals(exists1, true, "Should exist after saving");

      const exists2 = await repo.exists("does-not-exist");
      assertEquals(
        exists2,
        false,
        "Should not exist for non-existent template",
      );
  });

  await t.step("should list all templates", async () => {
    // Save multiple templates
    const templates = ["template1", "template2", "template3"];
    for (const id of templates) {
      const def = TemplateDefinition.create(`${id} content`, "yaml");
      if (def.ok) {
        const template = Template.create(id, def.data, `${id} description`);
        if (template.ok) {
          await repo.save(template.data);
        }
      }
    }

    const listResult = await repo.list();
    assertEquals(listResult.ok, true, "Should list templates successfully");
    if (listResult.ok) {
      for (const id of templates) {
        assertEquals(
          listResult.data.includes(id),
          true,
          `Should include ${id}`,
        );
      }
    }
  });

  await t.step("should cache loaded templates", async () => {
    const templateDef = TemplateDefinition.create("cached", "custom");
    if (templateDef.ok) {
      const template = Template.create(
        "cache-test",
        templateDef.data,
        "Cache test",
      );
      if (template.ok) {
        await repo.save(template.data);

        // First load
        const result1 = await repo.load("cache-test");
        assertEquals(result1.ok, true);

        // Second load (should use cache)
        const result2 = await repo.load("cache-test");
        assertEquals(result2.ok, true);

        if (result1.ok && result2.ok) {
          // Should be the same cached instance
          assertEquals(result1.data.getId(), result2.data.getId());
        }
      }
    }
  });

  await t.step("should handle different template formats", async () => {
    const formats = [
      { id: "json-template", format: "json" as const, content: "{}" },
      { id: "yaml-template", format: "yaml" as const, content: "key: value" },
      {
        id: "hbs-template",
        format: "handlebars" as const,
        content: "{{#if test}}",
      },
      { id: "custom-template", format: "custom" as const, content: "custom" },
    ];

    for (const { id, format, content } of formats) {
      const def = TemplateDefinition.create(content, format);
      if (def.ok) {
        const template = Template.create(id, def.data, `${format} template`);
        if (template.ok) {
          const saveResult = await repo.save(template);
          assertEquals(saveResult.ok, true, `Should save ${format} template`);

          const loadResult = await repo.load(id);
          assertEquals(loadResult.ok, true, `Should load ${format} template`);
          if (loadResult.ok) {
            assertEquals(loadResult.data.getDefinition().getFormat(), format);
          }
        }
      }
    }
  });

  // Cleanup
  await t.step("cleanup", async () => {
    await Deno.remove(testDir, { recursive: true });
  });
});

Deno.test("FileTemplateRepository - Error Handling Tests", async (t) => {
  await t.step("should handle permission errors gracefully", async () => {
    const repo = new FileTemplateRepository("/root/no-permission");

    const templateDef = TemplateDefinition.create("test", "json");
    if (templateDef.ok) {
      const template = Template.create(
        "perm-test",
        templateDef.data,
        "Permission test",
      );
      if (template.ok) {
        const result = await repo.save(template.data);
        assertEquals(result.ok, false, "Should fail with permission error");
        if (!result.ok) {
          assertExists(result.error.kind);
        }
      }
    }
  });

  await t.step("should handle corrupted template files", async () => {
    const testDir = await Deno.makeTempDir();
    const repo = new FileTemplateRepository(testDir);

    // Create a corrupted JSON file
    await Deno.writeTextFile(`${testDir}/corrupted.json`, "{ invalid json");

    const result = await repo.load("corrupted");
    // Should fail to load but not throw
    assertExists(result, "Should return result even for corrupted file");

    await Deno.remove(testDir, { recursive: true });
  });

  await t.step("should handle concurrent operations", async () => {
    const testDir = await Deno.makeTempDir();
    const repo = new FileTemplateRepository(testDir);

    const operations = [];
    for (let i = 0; i < 10; i++) {
      const def = TemplateDefinition.create(`content ${i}`, "json");
      if (def.ok) {
        const template = Template.create(
          `concurrent-${i}`,
          def.data,
          `Concurrent ${i}`,
        );
        if (template.ok) {
          operations.push(repo.save(template.data));
        }
      }
    }

    const results = await Promise.all(operations);
    for (const result of results) {
      assertEquals(result.ok, true, "All concurrent saves should succeed");
    }

    const listResult = await repo.list();
    if (listResult.ok) {
      assertEquals(
        listResult.data.length >= 10,
        true,
        "Should have saved all templates",
      );
    }

    await Deno.remove(testDir, { recursive: true });
  });
});

Deno.test("Repository Pattern - Abstraction Tests", async (t) => {
  await t.step("repository methods return Result types", async () => {
    const testDir = await Deno.makeTempDir();
    const repo = new FileTemplateRepository(testDir);

    // All repository methods should return Result type
    const loadResult = await repo.load("any-id");
    assertExists(loadResult.ok, "load should return Result");

    const listResult = await repo.list();
    assertExists(listResult.ok, "list should return Result");

    const templateDef = TemplateDefinition.create("test", "json");
    if (templateDef.ok) {
      const template = Template.create("test", templateDef.data, "test");
      if (template.ok) {
        const saveResult = await repo.save(template);
        assertExists(saveResult.ok, "save should return Result");
      }
    }

    // exists returns boolean directly (query method)
    const exists = await repo.exists("test");
    assertEquals(typeof exists, "boolean", "exists should return boolean");

    await Deno.remove(testDir, { recursive: true });
  });

  await t.step("repository maintains consistency", async () => {
    const testDir = await Deno.makeTempDir();
    const repo = new FileTemplateRepository(testDir);

    const def = TemplateDefinition.create("original content", "json");
    if (def.ok) {
      const template = Template.create("consistency-test", def.data, "test");
      if (template.ok) {
        await repo.save(template.data);

        // Update and save again
        const newDef = TemplateDefinition.create("updated content", "json");
        if (newDef.ok) {
          const updated = Template.create(
            "consistency-test",
            newDef.data,
            "updated",
          );
          if (updated.ok) {
            await repo.save(updated.data);

            // Load should return updated version
            const loaded = await repo.load("consistency-test");
            if (loaded.ok) {
              assertEquals(
                loaded.data.getDefinition().getDefinition(),
                "updated content",
                "Should load updated version",
              );
            }
          }
        }
      }
    }

    await Deno.remove(testDir, { recursive: true });
  });
});
