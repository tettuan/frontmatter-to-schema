import { assertEquals } from "jsr:@std/assert";
import { BasePropertyPopulator } from "../../../src/domain/schema/services/base-property-populator.ts";
import { Schema } from "../../../src/domain/schema/entities/schema.ts";
import { SchemaPath } from "../../../src/domain/schema/value-objects/schema-path.ts";
import { SchemaDefinition } from "../../../src/domain/schema/value-objects/schema-definition.ts";
import { TestDataFactory } from "../../helpers/test-data-factory.ts";
import { FrontmatterData } from "../../../src/domain/frontmatter/value-objects/frontmatter-data.ts";
import { TEST_EXTENSIONS } from "../../helpers/test-extensions.ts";

// Test helper to create schema from data
function createTestSchema(schemaData: any): Schema {
  const pathResult = SchemaPath.create("test.json");
  if (!pathResult.ok) throw new Error("Path creation failed");

  const definitionResult = SchemaDefinition.create(schemaData);
  if (!definitionResult.ok) throw new Error("Definition creation failed");

  const schemaResult = Schema.create(pathResult.data, definitionResult.data);
  if (!schemaResult.ok) throw new Error("Schema creation failed");

  return schemaResult.data;
}

function createTestFrontmatter(data: any): FrontmatterData {
  const result = TestDataFactory.createFrontmatterData(data);
  if (!result.ok) throw new Error("Frontmatter creation failed");
  return result.data;
}

Deno.test({
  name:
    "BasePropertyPopulator - should populate version from schema default value",
  fn: () => {
    // Arrange: Create schema with base property default
    const schemaData = {
      type: "object",
      properties: {
        version: {
          type: "string",
          [TEST_EXTENSIONS.BASE_PROPERTY]: true,
          [TEST_EXTENSIONS.DEFAULT_VALUE]: "1.0.0",
        },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();
    const frontmatterData = createTestFrontmatter({});

    // Act: Populate base properties
    const result = populator.populate(frontmatterData, schema);

    // Assert: Version should be populated with default value
    assertEquals(result.ok, true, "Base property population should succeed");
    if (!result.ok) return;

    const populatedData = result.data;
    const versionResult = populatedData.get("version");
    assertEquals(versionResult.ok, true, "Version should be accessible");
    if (versionResult.ok) {
      assertEquals(
        versionResult.data,
        "1.0.0",
        "Version should be populated with default value",
      );
    }
  },
});

Deno.test({
  name:
    "BasePropertyPopulator - should populate description from schema default",
  fn: () => {
    // Arrange
    const schemaData = {
      type: "object",
      properties: {
        description: {
          type: "string",
          [TEST_EXTENSIONS.BASE_PROPERTY]: true,
          [TEST_EXTENSIONS.DEFAULT_VALUE]: "Generated by frontmatter-to-schema",
        },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();
    const frontmatterData = createTestFrontmatter({});

    // Act
    const result = populator.populate(frontmatterData, schema);

    // Assert
    assertEquals(result.ok, true);
    if (!result.ok) return;

    const descriptionResult = result.data.get("description");
    assertEquals(
      descriptionResult.ok,
      true,
      "Description should be accessible",
    );
    if (descriptionResult.ok) {
      assertEquals(
        descriptionResult.data,
        "Generated by frontmatter-to-schema",
      );
    }
  },
});

Deno.test({
  name:
    "BasePropertyPopulator - should merge base properties with existing frontmatter data",
  fn: () => {
    // Arrange
    const schemaData = {
      type: "object",
      properties: {
        version: {
          type: "string",
          [TEST_EXTENSIONS.BASE_PROPERTY]: true,
          [TEST_EXTENSIONS.DEFAULT_VALUE]: "1.0.0",
        },
        title: {
          type: "string", // Non-base property
        },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();

    // Frontmatter data with existing properties
    const frontmatterData = createTestFrontmatter({
      title: "Existing Title",
      author: "John Doe",
    });

    // Act
    const result = populator.populate(frontmatterData, schema);

    // Assert: Should have both base and existing properties
    assertEquals(result.ok, true);
    if (!result.ok) return;

    const data = result.data;
    const versionResult = data.get("version");
    assertEquals(versionResult.ok, true, "Version should be accessible");
    if (versionResult.ok) {
      assertEquals(
        versionResult.data,
        "1.0.0",
        "Base property should be added",
      );
    }
    const titleResult = data.get("title");
    assertEquals(titleResult.ok, true, "Title should be accessible");
    if (titleResult.ok) {
      assertEquals(
        titleResult.data,
        "Existing Title",
        "Existing property should be preserved",
      );
    }
    const authorResult = data.get("author");
    assertEquals(authorResult.ok, true, "Author should be accessible");
    if (authorResult.ok) {
      assertEquals(
        authorResult.data,
        "John Doe",
        "Non-schema property should be preserved",
      );
    }
  },
});

Deno.test({
  name:
    "BasePropertyPopulator - should not override existing frontmatter values",
  fn: () => {
    // Arrange
    const schemaData = {
      type: "object",
      properties: {
        version: {
          type: "string",
          [TEST_EXTENSIONS.BASE_PROPERTY]: true,
          [TEST_EXTENSIONS.DEFAULT_VALUE]: "1.0.0",
        },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();

    // Frontmatter already has version
    const frontmatterData = createTestFrontmatter({
      version: "2.0.0", // Different from default
    });

    // Act
    const result = populator.populate(frontmatterData, schema);

    // Assert: Existing value should be preserved
    assertEquals(result.ok, true);
    if (!result.ok) return;

    const versionResult = result.data.get("version");
    assertEquals(versionResult.ok, true, "Version should be accessible");
    if (versionResult.ok) {
      assertEquals(
        versionResult.data,
        "2.0.0",
        "Existing frontmatter value should not be overridden",
      );
    }
  },
});

Deno.test({
  name: "BasePropertyPopulator - should handle schema without base properties",
  fn: () => {
    // Arrange
    const schemaData = {
      type: "object",
      properties: {
        title: { type: "string" }, // No base properties
        commands: { type: "array", items: { type: "string" } },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();
    const frontmatterData = createTestFrontmatter({ title: "Test" });

    // Act
    const result = populator.populate(frontmatterData, schema);

    // Assert: Should return unchanged data
    assertEquals(result.ok, true);
    if (!result.ok) return;

    const titleResult = result.data.get("title");
    assertEquals(titleResult.ok, true, "Title should be accessible");
    if (titleResult.ok) {
      assertEquals(titleResult.data, "Test");
    }
  },
});

Deno.test({
  name:
    "BasePropertyPopulator - should return error for invalid base property configuration",
  fn: () => {
    // Arrange: Schema with base property but missing default value
    const schemaData = {
      type: "object",
      properties: {
        version: {
          type: "string",
          [TEST_EXTENSIONS.BASE_PROPERTY]: true,
          // Missing default value
        },
      },
    };

    const schema = createTestSchema(schemaData);
    const populator = new BasePropertyPopulator();
    const frontmatterData = createTestFrontmatter({});

    // Act
    const result = populator.populate(frontmatterData, schema);

    // Assert: Should return error
    assertEquals(
      result.ok,
      false,
      "Should fail when base property lacks default value",
    );
    if (result.ok) return;

    assertEquals(
      result.error.kind,
      "InvalidSchema",
      "Error should indicate invalid schema",
    );
  },
});
